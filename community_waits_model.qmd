---
title: "A study of Community Waiting Lists, using queing theory to identify service gaps and prediciting additional capacity requirements to achieve zero patients at 52 week planning metrics. "
date: "`r Sys.Date()`"
author: S Wellesley-Miller
date-format: "D MMMM YYYY"
format:
  html:
    # Table of Contents options
    toc: true
    toc-depth: 3
    toc-location: left
    toc-title: Contents
    number-sections: false
    number-depth: 3
    # Render options
    anchor-sections: false
    html-table-processing: none
    html-math-method: katex
    # Code options
    code-tools:
      source: false
      toggle: false
      caption: none
    # code-fold: false
    # code-summary: "Show code"
    embed-resources: true
    standalone: true
    # URL options
    link-external-icon: true
    link-external-newwindow: true
    # References
    citations-hover: true
    footnotes-hover: true
    callout-appearance: simple
    callout-collapse: true
    cap-location: bottom
    title-block-banner: '#005EB8'
    backgroundcolor: '#ffffff'
    mainfont: 'Gill Sans MT'
    page-layout: full
execute:
  echo: false
  warning: false

---

```{r}
library(tidyverse)
library(janitor)
library(NHSRwaitinglist)
library(gt)
library(gtExtras)
library(geomtextpath)
library(forecast)
library(cli)

# name of region to run report for
region <- "SOUTH WEST"

# threshold of number of patients waiting over 52 weeks to run models for
threshold <- 50

# Waiting time target (weeks)
waiting_time_target <- 52

# primary target to achieve
# NOTE: It is not possible to calculate 100% achievement
target <- 0.99

achievement_value <- qexp(target)

# secondary waiting list target (18 weeks)
waiting_time_target_18 <- 18

# set target date for 52 wks
target_date <- as.Date("2026-03-31")

# secondary target to achieve
# NOTE: It is not possible to calculate 100% achievement
target_18 <- 0.92

achievement_value_18 <- qexp(target_18)

target_date_18 <- as.Date("2027-03-31")

#############
# data load #
#############
# 
# serv <- "udalsyndataprod.sql.azuresynapse.net"
# db <- "UDAL_Warehouse"
# 
# con_udal <- DBI::dbConnect(
#   drv = odbc::odbc(),
#   driver = "ODBC Driver 17 for SQL Server",
#   server = serv,
#   database = "UDAL_Warehouse",
#   authentication = "ActiveDirectoryInteractive"
# )
# 
# dat <- DBI::dbGetQuery(conn = con_udal, statement = paste0("
# 
# SELECT  [Period]
#       ,[Month]
#       ,[OrgRef]
#       ,[OrgName]
#       ,c.[Region_Name]
#       ,[STP_Code]
#       ,[STP_Name]
#       ,[Service]
#       ,[ServiceType]
#       ,[MetricID]
#       ,[MetricDescription] as Question
#       ,[TextResponses]
#       ,[MetricValue],
# 	  h.*
#   FROM [Reporting_SEFT_Sitreps_Published].[CommunityHealthServicesSitRep]  as c
# 
#   left join (select distinct icb_code, integrated_care_board_name, region_name from [Reporting_UKHD_ODS].[Provider_Hierarchies_ICB] where effective_to is null ) as h
# on c.stp_code = h.icb_code
# 
#   where month > DATEADD(mm,-40,GETDATE()) and
#   h.region_name = '", region, "'"))
# 


#saveRDS(dat, "dat.rds")
dat <- readRDS('dat.rds')

# clean names
df <- clean_names(dat) |>
  mutate(metric_value = as.numeric(metric_value))

# shorten org_names
df <- df |>
  mutate(
    org_name = str_remove(org_name, "NHS"),
    org_name = str_remove(org_name, "FOUNDATION"),
    org_name = str_remove(org_name, "TRUST"),
    org_name = str_squish(org_name)
  )

# calc latest date
latest_date <- max(df$month, na.rm = T)

# filter to waiting times
df_wait <- df |>
  filter(
    str_starts(metric_id, "RES001"),
    month >= latest_date %m-% months(6)
  ) |>
  arrange(
    org_name,
    month
  )

# filter to average waiting times
df_average <- df |>
  filter(
    metric_id == "RES002cii",
    month == latest_date
  ) |>
  select(org_name,
    service,
    mean_waits = metric_value
  )

# calculate current proportion waiting over 18 & 52 weeks
df_prop <- df |>
  filter(
    str_starts(metric_id, "RES001"),
    metric_id != "RES001c",
    month >= latest_date
  ) |>
  arrange(month) |>
  mutate(waits_52 = if_else(question %in% c(
    "Waiting 0-1 weeks",
    "Waiting >1-2 weeks",
    "Waiting >2-4 weeks",
    "Waiting >4-12 weeks",
    "Waiting >12-18 weeks",
    "Waiting >18-52 weeks"
  ),
  "Less than 52",
  "More than 52"
  ),
  waits_18 = if_else(question %in% c(
    "Waiting 0-1 weeks",
    "Waiting >1-2 weeks",
    "Waiting >2-4 weeks",
    "Waiting >4-12 weeks",
    "Waiting >12-18 weeks"
  ),
  "Less than 18",
  "More than 18"
  )) 


df_prop_52 <- df_prop |>
  summarise(
    metric_value = sum(metric_value),
    .by = c(
      month,
      waits_52,
      org_name,
      service
    )
  ) |>
  mutate(
    total = sum(metric_value),
    perc = metric_value / total * 100,
    .by = c(
      month,
      org_name,
      service
    )
  ) |>
  mutate(perc = if_else(is.nan(perc), 0, perc))

df_prop_18 <- df_prop |>
  summarise(
    metric_value = sum(metric_value),
    .by = c(
      month,
      waits_18,
      org_name,
      service
    )
  ) |>
  mutate(
    total = sum(metric_value),
    perc = metric_value / total * 100,
    .by = c(
      month,
      org_name,
      service
    )
  ) |>
  mutate(perc = if_else(is.nan(perc), 0, perc))


# filter our dataframe to just those over 52 weeks
over_52 <- df_prop_52 |>
  filter(
    waits_52 == "More than 52",
    metric_value > 0
  ) |>
  arrange(
    org_name,
    -perc
  )

# filter our dataframe to just those over 52 weeks
over_18 <- df_prop_18 |>
  filter(
    waits_18 == "Less than 18",
    perc < 92,
    metric_value > 0
  ) |>
  arrange(
    org_name,
    -perc
  )


# make a pretty table of our over X week waits
over_x_tab <-  function (data, org, selection) {

over_x_tab <- data |>
  filter(org_name == org) |>
  select(
    -month,
    -!!sym(selection),
    -org_name
  ) 

if (selection == 'waits_18') {
  over_x_tab <- over_x_tab |>
    arrange(perc)
}

over_x_tab <- over_x_tab |>
  gt() |>
  opt_row_striping(row_striping = FALSE) |>
  opt_table_font(font = 'Gill Sans MT', size = px(11)) |>
  gt_duplicate_column(perc,
    append_text = "_bar"
  ) |>
  fmt_number(
    columns = c(metric_value, total),
    use_seps = TRUE,
    decimals = 0
  ) |>
  fmt_percent(
    columns = perc,
    decimals = 1,
    scale_values = FALSE
  ) |>
  gt_plt_bar_pct(
    column = perc_bar, scaled = TRUE,
    fill = "#005EB8", background = "lightblue"
  ) |>
  tab_footnote(
    footnote = paste0(
      "Data taken from Community Health Services (CHS) SitRep downloaded as at ",
      format(Sys.Date(), "%Y-%m-%d")
    )
  ) 

if (selection == 'waits_18') {
  over_x_tab <- over_x_tab |>
      tab_header(
    title = paste0(org, ": Community 18 week waits as at ", format(latest_date, "%B %y")),
    subtitle = md("Waitings lists by provider and service with <92% patients waiting under 18 weeks")
  )|>
  cols_label(
    service = "Service",
    metric_value = "Patients waiting over 18 wks",
    total = "Total patients waiting",
    perc = "Percentage under 18 wks",
    perc_bar = "Target > 92%"
  ) 
    
} else {
  over_x_tab <- over_x_tab  |>
  tab_header(
    title = paste0(org, ": Community 52 week waits as at ", format(latest_date, "%B %y")),
    subtitle = md("Waitings lists by provider and service with patients waiting 52 weeks+")
  )|>
  cols_label(
    service = "Service",
    metric_value = "Patients waiting over 52 wks",
    total = "Total patients waiting",
    perc = "Percentage over 52 wks",
    perc_bar = "Target 0%"
  ) }


over_x_tab <- over_x_tab |>
  as_raw_html()

over_x_tab
}

#over_x_tab(over_18, 'CORNWALL PARTNERSHIP', 'waits_18')


# create weekly referral distributions
df_refs <- df_wait |>
  filter(metric_id == "RES001ci") |>
  mutate(referrals = metric_value * 1.1) |>
  summarise(
    mean_ref = mean(referrals, na.rm = T),
    sd_ref = sd(referrals, na.rm = T),
    .by = c(
      org_name,
      service
    )
  )

# calculate percentage of 52+ waits
df_waits_52 <- df_prop_52 |>
  filter(waits_52 == 'More than 52') |>
    select(
    org_name,
    service,
    num_52 = metric_value,
    perc_52 = perc
  ) |>
  mutate(perc_52 = round(perc_52, 2))

# calculate percentage of <18 waits
df_waits_18 <- df_prop_18 |>
  filter(waits_18 == 'Less than 18') |>
    select(
    org_name,
    service,
    num_18 = metric_value,
    perc_18 = perc
  ) |>
  mutate(perc_18 = round(perc_18, 2))
# 
# # calculate percentage of 52+ waits
# df_waits_52 <- df_wait |>
#   filter(
#     metric_id %in% c(
#       "RES001c",
#       "RES001cvii",
#       "RES001cviii"
#     ),
#     month >= latest_date
#   ) |>
#   select(
#     org_name,
#     service,
#     question,
#     metric_value
#   ) |>
#   pivot_wider(
#     names_from = question,
#     values_from = metric_value
#   ) |>
#   mutate(
#     perc_52 = (`Waiting >52-104 weeks` + `Waiting >104 weeks`) / `Total waiting list`,
#     perc_52 = if_else(is.nan(perc_52), 0, round(perc_52, 2)),
#     num_52 = (`Waiting >52-104 weeks` + `Waiting >104 weeks`)
#   ) |>
#   select(
#     org_name,
#     service,
#     perc_52,
#     num_52
#   )

# calculate removals
# monthly referrals into separate column
# and calculate removals
# assumption that
# previous waits + referrals - current waits = number removed

df_rems <- df_wait |>
  filter(metric_id %in% c(
    "RES001ci",
    "RES001c"
  )) |>
  select(
    org_name,
    month,
    service,
    question,
    metric_value
  ) |>
  pivot_wider(
    names_from = question,
    values_from = metric_value
  ) |>
  mutate(referrals = `Waiting 0-1 weeks` * 4.3) |>
  arrange(
    org_name,
    service,
    month
  ) |>
  mutate(
    prev_wait_ref = lag(`Total waiting list`, 1) + referrals,
    removals = prev_wait_ref - `Total waiting list`,
    net_change = referrals - removals,
    wk_rem = removals / 4.3,
    .by = c(
      org_name,
      service
    )
  )

# summary removals
df_removals <- df_rems |>
  summarise(
    mean_removals = mean(wk_rem, na.rm = T),
    sd_removals = sd(wk_rem, na.rm = T),
    .by = c(
      org_name,
      service
    )
  )

# dataset with current wait list size and summary demand and capacity metrics
df_summary <- df_wait |>
  filter(
    metric_id == "RES001c",
    month == latest_date
  ) |>
  select(org_name,
    service,
    integrated_care_board_name,
    total_waits = metric_value
  ) |>
  left_join(df_removals,
    by = join_by(
      org_name,
      service
    )
  ) |>
  left_join(df_refs,
    by = join_by(
      org_name,
      service
    )
  ) |>
  left_join(df_average,
    by = join_by(
      org_name,
      service
    )
  ) |>
  left_join(df_waits_52,
    by = join_by(
      org_name,
      service
    )
  ) |>
    left_join(df_waits_18,
    by = join_by(
      org_name,
      service
    )
  ) |>
  mutate(dq_tag = case_when(mean_removals < 0 ~ 1,
    is.na(sd_removals) ~ 1,
    mean_ref < 0 ~ 1,
    is.na(sd_ref) ~ 1,
    .default = 0
  ))

############
# WL Model #
############

wks_to_target <- as.numeric(round(difftime(strptime(target_date, format = "%Y-%m-%d"),
  strptime(latest_date, format = "%Y-%m-%d"),
  units = "weeks"
), 0))

wks_to_target_18 <- as.numeric(round(difftime(strptime(target_date_18, format = "%Y-%m-%d"),
  strptime(latest_date, format = "%Y-%m-%d"),
  units = "weeks"
), 0))


df_model <- df_summary |>
  mutate(
    wl_load = calc_queue_load(mean_ref, mean_removals),
    target_mean_wait = calc_target_mean_wait(waiting_time_target, achievement_value),
    target_mean_wait_18 = calc_target_mean_wait(waiting_time_target_18, achievement_value_18),
    target_queue_size = calc_target_queue_size(mean_ref, waiting_time_target),
    target_queue_size_18 = calc_target_queue_size(mean_ref, waiting_time_target_18),
    queue_ratio = total_waits / target_queue_size,
    queue_ratio_18 = total_waits / target_queue_size_18,
    additional_capacity = calc_relief_capacity(
      demand = mean_ref,
      queue_size = total_waits,
      target_queue_size = target_queue_size,
      time_to_target = wks_to_target
    ),
    additional_capacity_18 = calc_relief_capacity(
      demand = mean_ref,
      queue_size = total_waits,
      target_queue_size = target_queue_size_18,
      time_to_target = wks_to_target_18
    ),
    wl_pressure = calc_waiting_list_pressure(
      mean_waits,
      waiting_time_target
    ),
    wl_pressure_18 = calc_waiting_list_pressure(
      mean_waits,
      waiting_time_target_18
    ),
    coef_ref = sum((1/sd_ref) / (1/mean_ref)),
    coef_rem = sum((1/sd_removals) / (1/mean_removals)),
    tar_capacity = calc_target_capacity(
      demand = mean_ref,
      target_wait = waiting_time_target,
      factor = 5,
      cv_demand = coef_ref,
      cv_capacity = coef_rem
    ) * 1.1,
    tar_capacity_18 = calc_target_capacity(
      demand = mean_ref,
      target_wait = waiting_time_target_18,
      factor = 5,
      cv_demand = coef_ref,
      cv_capacity = coef_rem
    ) * 1.1,

                   
    .by = c(org_name, service)
  )


# df model in a table
# One table per provider
#org <- "CORNWALL PARTNERSHIP"

provider_model_table <- function(org, waits)  {


tab_data <- if(waits == '52') 
  {df_model |>
  filter(org_name == org,
         mean_ref >0) |>
  mutate(
    dq_tag = if_else(mean_removals < 0, 1, dq_tag),
    perc_52 = perc_52,
    mean_removals_dup = mean_removals
  ) |>
  arrange(-total_waits) |>
  select(
    service,
    dq_tag, # dq
    mean_ref, # d&c
    mean_removals, # d&c
    wl_load, # d&c
    mean_waits, # waits time
    target_mean_wait, # waits time
    total_waits, # total waits
    target_queue_size, # total waits
    queue_ratio, # total waits
    perc_52, # performance
    wl_pressure, # performance
    mean_removals_dup, # capacity
    additional_capacity, # capacity
    tar_capacity  )} else {
  df_model |>
  filter(org_name == org,
         mean_ref >0,
         num_18 > 0 ) |>
  mutate(
    dq_tag = if_else(mean_removals < 0, 1, dq_tag),
    perc_52 = perc_52,
    mean_removals_dup = mean_removals
  ) |>
  arrange(perc_18) |>
  select(
    service,
    dq_tag, # dq
    mean_ref, # d&c
    mean_removals, # d&c
    wl_load, # d&c
    mean_waits, # waits time
    target_mean_wait_18, # waits time
    total_waits, # total waits
    target_queue_size_18, # total waits
    queue_ratio_18, # total waits
    perc_18, # performance
    wl_pressure_18, # performance
    mean_removals_dup,# capacity
    additional_capacity_18, # capacity
    tar_capacity_18) # capacity 
  }
  
  if(waits == '52') { 
  model_table <- tab_data |> 
  gt() |>
  opt_row_striping(row_striping = FALSE) |>
  opt_table_font(font = 'Gill Sans MT', size = px(11)) |>

  fmt_number(
    rows = everything(),
    decimals = 1,
    use_seps = TRUE,
    sep_mark = ","
  ) |>
  tab_spanner(
    label = "Demand and Capacity",
    columns = c(
      mean_ref,
      mean_removals,
      wl_load
    )
  ) |>
  tab_spanner(
    label = "Waiting Times",
    columns = c(
      mean_waits,
      target_mean_wait,
      total_waits,
      target_queue_size,
      queue_ratio
    )
  ) |>
  tab_spanner(
    label = "Performance",
    columns = c(
      perc_52,
      wl_pressure
    )
  ) |>
  tab_spanner(
    label = "Capacity Projections to Achieve Target",
    columns = c(
      mean_removals_dup,
      additional_capacity,
      tar_capacity
    )
  ) |>
  cols_label(
    service = "Service",
    dq_tag = "dq", # dq
    mean_ref = "Mean referrals", # d&c
    mean_removals = "Mean capacity", # d&c
    wl_load = "(i) WL Load", # d&c
    mean_waits = "Actual mean waits", # waits time
    target_mean_wait = "(ii) Target mean waits", # waits time
    total_waits = "Current total waits", # total waits
    target_queue_size = "(iii) Target total waits", # total waits
    queue_ratio = "(iv) Queue ratio", # total waits
    perc_52 = "%Waiting 52 Wks+", # performance
    mean_removals_dup = "Current capacity",
    wl_pressure = "(v) Pressure", # performance
    additional_capacity = "(vi) Relief capacity", # capacity
    tar_capacity = "(vii) Stable capacity" # capacity
  ) |>
    tab_style(
    style = list(
      cell_fill(color = "#41B6E6", alpha = 0.5)
    ),
    locations = cells_body(
      columns  = c(13, 14, 15)
    )
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "#CCA00F", alpha = 0.5)
    ),
    locations = cells_body(
      rows = dq_tag == 1
    )
  ) |>
  cols_hide(columns = dq_tag) |>
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_body(
      columns = c(5, 7, 9, 10, 12, 13, 14)
    )
  ) |>
  gt_plt_bar_pct(
    column = perc_52,
    fill = "#DA291C",
    scaled = TRUE,
    labels = T
  ) |>
  tab_header(
    title = paste0(org, ": Community Services waits as at ", format(latest_date, "%B %y"), " : Analysis to achieve zero at 52 weeks target by ", format(target_date, '%b %y')),
    subtitle = md("Waiting lists by service with waiting list metrics")
  ) |>
  tab_footnote(
    footnote = md(paste0(
      "**NOTE:** *Rows in orange indicate a data quality issue or inconsistent data*<br>Data taken from Community Health Services (CHS) SitRep downloaded as at ",
      format(Sys.Date(), "%Y-%m-%d")
    ))
  ) |>
  tab_style(
    style = cell_borders(
      sides = c("right"),
      color = "lightgrey",
      weight = px(1)
    ),
    locations = cells_body(
      columns = c(1, 5, 10, 12)
    )
  ) |>
    tab_style(
      style = cell_text(color = "red"),
      locations = cells_body(
        columns = mean_removals,
        rows = mean_removals <0
      )
    )|>
    tab_style(
      style = cell_text(weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = c(13,14,15)
      )
    ) |>
    tab_style(
      style = cell_text(color = "red", weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = wl_load,
        rows = wl_load >=1.05
      )
    ) |>
    tab_style(
      style = cell_text(color = "red", weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = queue_ratio,
        rows = queue_ratio >2
      )
    )|>
    tab_style(
      style = cell_text(color = "red", weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = wl_pressure,
        rows = wl_pressure >=1.05
      )
    )} else {
       model_table <- tab_data |> 
  gt() |>
  opt_row_striping(row_striping = FALSE) |>
  opt_table_font(font = 'Gill Sans MT', size = px(11)) |>

  fmt_number(
    rows = everything(),
    decimals = 1,
    use_seps = TRUE,
    sep_mark = ","
  ) |>
  tab_spanner(
    label = "Demand and Capacity",
    columns = c(
      mean_ref,
      mean_removals,
      wl_load
    )
  ) |>
  tab_spanner(
    label = "Waiting Times",
    columns = c(
      mean_waits,
      target_mean_wait_18,
      total_waits,
      target_queue_size_18,
      queue_ratio_18
    )
  ) |>
  tab_spanner(
    label = "Performance",
    columns = c(
      perc_18,
      wl_pressure_18
    )
  ) |>
  tab_spanner(
    label = "Capacity Projections to Achieve Target",
    columns = c(
      mean_removals_dup,
      additional_capacity_18,
      tar_capacity_18
    )
  ) |>
  cols_label(
    service = "Service",
    dq_tag = "dq", # dq
    mean_ref = "Mean referrals", # d&c
    mean_removals = "Mean capacity", # d&c
    wl_load = "(i) WL Load", # d&c
    mean_waits = "Actual mean waits", # waits time
    target_mean_wait_18 = "(ii) Target mean waits", # waits time
    total_waits = "Current total waits", # total waits
    target_queue_size_18 = "(iii) Target total waits", # total waits
    queue_ratio_18 = "(iv) Queue ratio", # total waits
    perc_18 = "%Waiting <18 Wks", # performance
    mean_removals_dup = "Current capacity",
    wl_pressure_18 = "(v) Pressure", # performance
    additional_capacity_18 = "(vi) Relief capacity", # capacity
    tar_capacity_18 = "(vii) Stable capacity" # capacity
  ) |>
    tab_style(
    style = list(
      cell_fill(color = "#41B6E6", alpha = 0.5)
    ),
    locations = cells_body(
      columns  = c(13, 14, 15)
    )
  ) |>
  tab_style(
    style = list(
      cell_fill(color = "#CCA00F", alpha = 0.5)
    ),
    locations = cells_body(
      rows = dq_tag == 1
    )
  ) |>
  cols_hide(columns = dq_tag) |>
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_body(
      columns = c(5, 7, 9, 10, 12, 13, 14)
    )
  ) |>
  gt_plt_bar_pct(
    column = perc_18,
    fill = "#DA291C",
    scaled = TRUE,
    labels = T
  ) |>
  tab_header(
    title = paste0(org, ": Community Services waits as at ", format(latest_date, "%B %y"), " : Analysis to achieve 92% of patients waiting less than 18 weeks by ", format(target_date_18, '%b %y')),
    subtitle = md("Waiting lists by service with waiting list metrics")
  ) |>
  tab_footnote(
    footnote = md(paste0(
      "**NOTE:** *Rows in orange indicate a data quality issue or inconsistent data*<br>Data taken from Community Health Services (CHS) SitRep downloaded as at ",
      format(Sys.Date(), "%Y-%m-%d")
    ))
  ) |>
  tab_style(
    style = cell_borders(
      sides = c("right"),
      color = "lightgrey",
      weight = px(1)
    ),
    locations = cells_body(
      columns = c(1, 5, 10, 12)
    )
  ) |>
    tab_style(
      style = cell_text(color = "red"),
      locations = cells_body(
        columns = mean_removals,
        rows = mean_removals <0
      )
    )|>
    tab_style(
      style = cell_text(weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = c(13,14,15)
      )
    ) |>
    tab_style(
      style = cell_text(color = "red", weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = wl_load,
        rows = wl_load >=1.05
      )
    ) |>
    tab_style(
      style = cell_text(color = "red", weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = queue_ratio_18,
        rows = queue_ratio_18 >2
      )
    )|>
    tab_style(
      style = cell_text(color = "red", weight = 'bolder', size = 'large'),
      locations = cells_body(
        columns = wl_pressure_18,
        rows = wl_pressure_18 >=1.05
      )
    ) 
    }
  
model_table
  
  
}

# provider_model_table ('LIVEWELL SOUTHWEST', 18)

# 12 month forecast dates
dts <- data.frame(date = seq.Date(from = latest_date %m+% months(1),
                                  to = target_date_18,
                                  by = "month"))

# create dataframe with blank dates to insert predictions
trajectory <- crossing(df_model, dts)

# create a linear trajectory to target
trajectory <- trajectory |>
  mutate(traj = case_when(date == min(date) ~ total_waits,
                          date == floor_date(target_date) ~ target_queue_size,
                          date > target_date ~ target_queue_size,
                          .default = NA),
        traj_18 = case_when(date == min(date) ~ total_waits,
                            date == target_date_18 ~ target_queue_size_18,
                            .default = NA
  )) |>
  mutate(traj = na.interp(traj),
         traj_18 = na.interp(traj_18))

dq_issues <- df_model |>
  filter(
    dq_tag == 1,
    total_waits >= 50
  ) |>
  select(
    org_name,
    service,
    total_waits,
    num_52,
    perc_52,
    num_18,
    perc_18
  )

dq_tab <-dq_issues |>
  gt() |>
  fmt_number(
    columns = c(total_waits, num_52, num_18),
    use_seps = TRUE,
    decimals = 0
  ) |>
  fmt_percent(
    columns = c(perc_52, perc_18),
    decimals = 1,
    scale_values = FALSE
  ) |>
  cols_label(
    org_name = "Provider name",
    service = "Service",
    total_waits = "Total Waits",
    num_52 = "Patients waiting over 52 wks",
    perc_52 = "Percentage waiting over 52 wks",
    num_18 = "Patients waiting under 18 wks",
    perc_18 = "Percentage waiting under 18 wks"
  ) |>
    opt_row_striping(row_striping = FALSE) |>
  opt_table_font(font = 'Gill Sans MT', size = px(12)) 

# filter to those with > threshold number of 52 week waits
# also drop those waiting lists where there is a dq tag.
wl_model <- df_model |>
  filter(
    num_52 >= threshold,
    dq_tag == 0
  ) |>
  arrange(-num_52) |>
  mutate(
    chk = if_else(total_waits < target_queue_size, 1, 0)
  )

wl_model_18 <- df_model |>
  filter(
    num_18 >= threshold,
    perc_18 < 92,
    dq_tag == 0
  ) |>
  arrange(-num_18) |>
  mutate(
    chk = if_else(total_waits < target_queue_size, 1, 0)
  )

wl_model <- wl_model |>
  bind_rows(wl_model_18) |>
  distinct() |>
  mutate(row_no = row_number())


# function to model simulation
sim_func <- function(run_id, i) {
  
  iteration <- wl_model |>
    filter(row_no == i)

  # create a wl dataframe of current size
  current_wl1 <-
    data.frame(
      Referral = rep(latest_date, iteration$total_waits[1]),
      Removal = rep(as.Date(NA), iteration$total_waits[1])
    )

  sd <- latest_date %m+% months(1)
  ed <- target_date_18
  dem <- iteration$mean_ref[1]
  cap <- iteration$mean_removals[1]
  wl <- current_wl1

  sim <- wl_simulator(
    start_date = sd,
    end_date = ed,
    demand = dem,
    capacity = cap,
    waiting_list = wl
  )

  cbind(wl_queue_size(sim), run_id)
}



create_peformance_dataframe <- function(i) {
  # filter data to an iteration
  iteration <- wl_model |>
    filter(row_no == i)

  # create a sequence of 50 iterations for monte carlo analysis
  run_sequence <- 1:50

  # run sim function n times to get monte carlo results
  stoc_preds <- lapply(run_sequence, sim_func, i)

  # pull the predictions
  mc_bind <- do.call("rbind", stoc_preds)

  # calculate means and quantiles
  mc_agg <-
    aggregate(
      queue_size ~ dates,
      data = mc_bind,
      FUN = \(x) {
        c(
          mean_q = mean(x),
          median_q = median(x),
          lower_95CI = mean(x) - (1.96 * (sd(x) / sqrt(length(x)))),
          upper_95CI = mean(x) + (1.96 * (sd(x) / sqrt(length(x)))),
          q_25 = quantile(x, .005, names = FALSE),
          q_75 = quantile(x, .995, names = FALSE)
        )
      }
    )

  # put aggreagtes into dataframe
  mc_agg <- data.frame(dates = as.Date(mc_agg$dates), unlist(mc_agg$queue_size))

  # reformat dates to end of month
  mc_agg <- mc_agg |>
    filter(day(dates) == day(ceiling_date(dates, "month") - days(1)))

  # pull historical actual total waits
  cur <- df_wait |>
    filter(
      org_name == iteration$org_name[1],
      service == iteration$service[1],
      metric_id == "RES001c"
    )

  # pull trajectory from trajectory dataframe
  traj_pred <- trajectory |>
    filter(
      org_name == iteration$org_name[1],
      service == iteration$service[1]
    )

  combined <- bind_rows(
    cur,
    mc_agg,
    traj_pred
  ) |>
    mutate(month = ceiling_date(month, "month") - days(1))

  combined
}

# create empty dataframe to collect results
  combined_data <- data.frame()
  
# run model for all   
# cli_progress_bar("processing data", total = max(wl_model$row_no))  
#   
# for (i in (1:max(wl_model$row_no))) {
#   combined_data <- combined_data |>
#     bind_rows(create_peformance_dataframe(i))
#   cli_progress_update()
#   
# }


#saveRDS(combined_data, "combined_data.rds")
combined_data <- readRDS('combined_data.rds')

combined_data <-  combined_data |>
  mutate(include_52 = if_else(num_52 > 0, 1, 0),
         include_18 = if_else(perc_18 < 92, 1, 0)) |>
  fill(include_52, .direction = 'up') |>
  fill(include_18, .direction = 'up') |>
  fill(org_name, .direction = 'down') |>
  fill(service, .direction = 'down')

list_52 <- combined_data |>
  filter(include_52 == 1) |>
  select(org_name,
         service) |>
  unique()

list_18 <- combined_data |>
  filter(include_18 == 1) |>
  select(org_name,
         service) |>
  unique()
  
# function to plot predictions and trajectories
plot_predictions_trajectory <- function(org, serv, traj = F, wait) {
  
  wt <- if_else(wait == '18', )
  
  com <- combined_data |>
    filter()

  # filter data to an iteration
  iteration <- wl_model |>
    filter(row_no == i)

  # plot predictions + target + trajectory
  plot <- com |>
    ggplot() +
    geom_textpath(aes(x = month, y = metric_value), 
                  label = "Actuals", hjust = 0.3, 
                  straight = TRUE) +
    geom_textpath(aes(x = dates, y = mean_q), 
                  linetype = "dashed", 
                  label = "Predicted", 
                  hjust = 0.3, 
                  straight = TRUE) +
    geom_ribbon(aes(x = dates, ymin = q_25, ymax = q_75), alpha = 0.5, fill = "lightblue") +
    theme_minimal() +
    labs(
      title = paste0(iteration$org_name[1], "\n", iteration$service[1]),
      subtitle = paste0("Projected waiting list size to ", format(target_date, "%d %B %y"), "\nAlso showing trajectory required to achieve 52wk target"),
      x = NULL,
      y = "Number of patients waiting"
    ) +
    scale_x_date(
      date_breaks = "2 month",
      date_labels = "%b %y"
    )

  if (traj == T) {
    plot <- plot +
      geom_textpath(aes(x = date, y = traj), linetype = "longdash", label = "Trajectory to achieve target", hjust = 0.3, straight = TRUE, color = "red") +
      geom_texthline(aes(yintercept = iteration$target_queue_size[1], label = "Target waiting list size", hjust = 0.1), color = "red")
  }
  plot
}




```

# Abstract

This study investigates strategies for eliminating community waiting lists exceeding 52 weeks within Community Health Services (CHS). Utilising data from CHS SitReps, it analyses key metrics of load and pressure at both provider and service levels. Queuing theory is applied to current waiting times to forecast future performance and determine the additional capacity needed to achieve national targets. Furthermore, the analysis quantifies the ongoing capacity required to maintain a steady state on the waiting list, preventing future backlogs. This research provides actionable insights for optimising resource allocation and improving patient access to community health services.

# Background

The Community Health Services (CHS) Situation Report (SitRep)^(1)^ serves as a standardised data collection instrument, aggregating monthly metrics pertaining to waiting lists and waiting times within both Children and Young People's (CYP) and Adult community health service sectors. Healthcare providers submit consolidated data at the service line level, irrespective of the multiplicity of Integrated Care Boards (ICBs) or geographical regions under which their services operate. While the SitRep encompasses a broad spectrum of NHS-commissioned community health services, it is acknowledged that its coverage may not be exhaustive across all localised healthcare systems.

A key operational objective is to eliminate instances of patients waiting more than 52 weeks for community health services. This analysis focuses on identifying breaches of this planning target. Furthermore, it employs modeling techniques to ascertain an ideal waiting list size conducive to achieving this target, quantifies the additional capacity required for its attainment, and delineates the ongoing requirements necessary to establish a steady-state operational equilibrium. A number of waiting list metrics are computed to facilitate a comprehensive understanding of prevailing waiting list pressures and to identify strategic intervention opportunities.

# Method

Data was taken from Community Health Services SitRep and analysed using R statistical software^(2)^ and NHS-R waiting list library^(3)^.

Data was analysed at provider and service level. The rationale being that capacity across services is not interchangeable. 

Where there are at least 50 patients waiting over 52 weeks, further modelling has been carried out to calculate addition capacity requirements to achieve target by March 2026 and also to calculate optimal size of waiting list and capacity required once target has been met.  This is aimed at supporting planning and resource allocation for services.  Modelling has been conducted using "Little's Law" queuing theory ^(4)^^(5)^ and applied to NHS waits as suggested by Fong et all^(6)^. 

## Tables showing services with patients waiting over 52 weeks 

```{r}
#| results: asis
#| echo: false
#| warning: false


cat('::: {.panel-tabset}  \n\n')

waits <- c('waits_52', 'waits_18')

for (i in waits) {

     lis <- if (i=='waits_18') {
        lis = over_18
      } else
      {lis = over_52}
  
  list_of_orgs <- unique(lis$org_name)
  
  label <- if (i=='waits_18') {
        '18 week waits'} else
      {'Over 52 week waits'}
  
  cat('### ',label,'   \n\n')

  cat('::: {.panel-tabset}  \n\n')

   for (j in list_of_orgs) {
     
       cat('#### ', j,'   \n')
     
       data <- if (i=='waits_18') {
         data = over_18
       } else
       {data = over_52}
       cat(knitr::knit_print(over_x_tab(data, j, i)))
       cat('\n')
       cat('\n')
   }
 
 cat('::: \n\n')

}
cat('::: \n\n')


```







Certain assumptions were made with the dataset in derive variables that were not existent in the data.

## Referral calculation 

The snapshot position of patients waiting between 0-1 weeks was taken as a proxy for the number of referrals received.  The mean was taken over the last 6 months to provide an average and standard deviations were calculated around this mean to model a distribution of variability to allow for a scholastic model. For pathways where there were patients waiting over a year for services, it was deemed unlikely that patients were being seen in their first week.  This average was multiplied by 4.3 to give an estimate of monthly referrals.

## Capacity calculation

Capacity is calculated as the number of patients being removed from the waiting list.  

This is calculated as follows:

**(Previous month's total waits + Current month referrals) - Current month's total waits**

The capacity calculation was analysed for the previous 6 months to give a distribution around a mean.

This capacity calculation simply counts the number of patients being removed and does not account for the activity or specialist capacity required to achieve a removal.  This is beyond the scope of this analysis.

## Data quality

This data is received at an aggregate level and it it is not possible to verify the data at a patient level to assure consistency.  Data quality checks were in place to identify where there was incomplete data across the calibration period.

Further removals from the the analytical pipeline when the capacity calculation returned a negative result.  This would indicate additional patients appearing on the waiting list, other than means of a referral.  This could not be accounted for and the assumption has been made that the data quality is poor and these features have are not possible to model with any degree of confidence.

### Table showing which providers and service lines had data quality issues and removed from the modelling analysis

```{r}

#dq_tab

```


# Results

Utilising the principles of Little's laws we can assert certain facts about the waiting list based on queuing theory principles.  This can give us powerful metrics to quantify the load and pressure on a waiting list.

### Waiting list predictions

For waiting lists that have at least 50 patients waiting over 52 weeks and where there is assurance of data quality we can run stochastic predictions of future waiting list positions.  These are run multiple times (Monte Carlo method^(7)^) to achieve an average and 75% confidence intervals around the prediction.  These are predictions assuming referral and capacity stays the same as the previous 6 months which was used to calibrate the model.    

### Waiting list predictions by provider and service.

```{r}
#| results: asis
#| echo: false
#| warning: false
# 
# 
# cat('::: {.panel-tabset}  \n\n')
# 
# list_of_orgs <- unique(wl_model$org_name)
# 
# for (i in list_of_orgs) {
# 
#   list_of_services<-wl_model$service[wl_model$org_name == i]
# 
#   cat('## ',i,'   \n\n')
# 
#   cat('::: {.panel-tabset}  \n\n')
# 
#   for (j in list_of_services) {
#       row <- wl_model$row_no[wl_model$org_name == i & wl_model$service == j]
#       cat('### ', j,'   \n')
#       p <- plot_predictions_trajectory(row, F)
#       print(p)
#       cat('\n')
#       cat('\n')
#   }
# 
# cat('::: \n\n')
# 
# }
# cat('::: \n\n')


```



### (i) Waiting list 'load'

The first principle is that capacity must be larger than demand, otherwise the waiting list size will grow indefinitely.

We can calculate the load by comparing the demand to the capacity. This is not a straight ratio, but takes into account statistical variation.  

If the load is greater than 1, then the queue is unstable, and the waiting list will grow indefinitely. If the load is less than 1, then the queue will be stable and the load is the proportion of the time that that waiting list is non-empty.

If the load on a queue is less than 1 then the chance of missing the target halves each time we increase the target by some fixed number of days.

### (ii) Target waiting time

If we want to have a chance between 1.8%-0.2% of not achieving a waiting time target, then the average patient should have a waiting time between a quarter and a sixth of the target.  

This has been calculated against the target of 0 patients waiting 52 weeks or longer.

### (iii) Recommended queue size to achieve target

Little’s Law. Assuming capacity exceeds demand, the average queue size is demand multiplied by average waiting time.  If we want the average waiting time to be a quarter of the target, then Little’s Law leads states target queue size is demand multiplied by target wait, divided by 4.

### (iv) Queue ratio

If the waiting list size is over twice the target queue size, then we consider that special measures are needed to increase capacity, and reduce waiting list size.

This calculation also shows us where we have far smaller waiting lists than necessary to achieve target.  

### (v) Waiting list pressure

For a waiting list with target waiting time, the pressure on the waiting list is twice the mean waiting time divided by the target waiting time. The pressure of any given waiting list should be less than 1. If the pressure is greater than 1 then the waiting list is most likely going to miss its target.

Measuring waiting list pressure can give a comparative measure with which to compare waiting lists, and help make resource allocation decisions.

Table showing waiting list metrics across providers and then by service.

###  (vi) Relief capacity

If the actual queue size is more than double the target queue size, then decide on a target date by which the queue will be brought down, and apply the necessary relief capacity.

In this analysis we have assumed a target to achieve performance of 0 at 52 weeks by `r `  xxdate

As discussed above if the queue size is more than double its target then capacity should be increased temporarily. However, once the queue size is within an acceptable range, we can maintain the waiting time target with what is potentially a much smaller capacity allocation to the waiting list.

### (vii) Steady capacity

We know the mean waiting time and queue size of a waiting list operating at its target equilibrium. Now we calculate a capacity allocation that will maintain this equilibrium in the long run.  Assuming that the referral rate remains consistent.

Target capacity formula, based on the Pollaczek-Khinchine^(8)^ formula. The target capacity depends on demand, plus an additional capacity which is based on service variability, and the waiting time target.

### Tables showing waiting list metrics

The following tables show by provider, current waiting list position as well as calculated waiting list metrics.

There are tabs for the 52 week wait modelling as well as modelling to achieve 92% at 18 weeks hythophetical target.

```{r}
#| output: asis
# list_order <- unique(df_model$org_name)
# 
#  res <- purrr::map_chr(list_order, \(hw) {
#                            knitr::knit_child(text = c(
#                              "### `r hw`",
#                              "", 
#                              "```{r}",
#                              "#| echo: false",
#                              "#| warning: false",
#                              "provider_model_table(hw)",
#                              "```",
#                              "",
#                              ""
#                            ), envir = environment(), quiet = TRUE)
#                          })
#  
#  cat(res, sep = '\n')
```



### 52 Week waits - predictions and trajectory of overall waits to achieve target

These graphs show the modeled 52 week waits, with predictions and required trajectories to achieve 0 at 52 weeks by  target date.

```{r}
#| results: asis
#| echo: false
#| warning: false

# 
# cat('::: {.panel-tabset}  \n\n')
# 
# list_of_orgs <- unique(wl_model$org_name)
# 
# for (i in list_of_orgs) {
# 
#   list_of_services<-wl_model$service[wl_model$org_name == i]
# 
#   cat('## ',i,'   \n\n')
# 
#   cat('::: {.panel-tabset}  \n\n')
# 
#   for (j in list_of_services) {
#       row <- wl_model$row_no[wl_model$org_name == i & wl_model$service == j]
#       cat('### ', j,'   \n')
#       p <- plot_predictions_trajectory(row, T)
#       print(p)
#       cat('\n')
#       cat('\n')
#   }
# 
# cat('::: \n\n')
# 
# }
# cat('::: \n\n')
# 

```


# Discussion

This analysis, while providing strategic-level insights, is predicated on a set of high-level assumptions and should not be interpreted as a granular simulation. The primary constraint lies in the current unavailability of robust, high-confidence data within NHS England for a more comprehensive investigation.


A notable data aggregation issue stems from independent providers operating across multiple Integrated Care Boards (ICBs). These providers often submit consolidated data to a lead ICB, potentially leading to an under representation of specific services at the local ICB level.


The current capacity gap assessment is based on existing referral volumes. Future analytical iterations could incorporate additional scenarios to model the impact of fluctuating referral demand on capacity requirements.
 
## Data quality and future enhancements
 
The scope of this report was limited to the national target of zero patients waiting over 52 weeks. Subsequent analyses could expand to evaluate the achievement of an 18-week target, a parameter not included in the present study or part of current planning guidance.


A significant limitation is the reliance on aggregate-level situation report (sit rep) data, which is characterised by its poor quality. This precludes data verification and issue identification at a patient level. Prospective data sources, such as Faster Data Flows (FDF) data, offer a potential solution. FDF data, being patient-level, would enable patient-level assurance and a more precise understanding of patient pathways. Furthermore, linking patient-level datasets with activity data could provide a deeper understanding of the capacity required to clear waiting lists. 
 
## Utility of the analysis despite data limitations
 
Despite the inherent limitations in data robustness, this analysis retains considerable utility in highlighting the pressures on waiting lists. On the surface, we might assume that growing a waiting list is always a bad thing. When dealing with a health economy, we must consider the ‘opportunity cost’: what benefits we forgo by using our resources in one place rather than another. When applied to a large, complex health economy, this might mean we increase a waiting list, within an acceptable limit, in order to release resources/staff/funding to be used elsewhere. 

So our task here is to work out how large the waiting list can grow whilst still meeting target, setting a time period to do it over, then reducing capacity accordingly. Again that the optimisation characteristics are based on the zero at 52 weeks, perhaps a more robust plan would be around achievement of an 18 week target, however this does not currently apply to community waiting lists.  Additional modelling of waiting lists to an 18 week target could be an extension of this analysis.


# Confidentiality 

All data used in this report is publicly available and thus there are barriers to sharing this report.  

The code to produce this report is freely available under MIT licence at www.github   

> Contact  
> [**Simon Wellesley-Miller**](mailto:Simon.Wellesley-Miller@nhs.net)\
> *Senior Analytical Manager*  
>   
> South West Intelligence and Insights  
> NHS England  
> Version 1.0 27 June 2025


# Citations

^(1)^ https://www.england.nhs.uk/statistics/statistical-work-areas/community-health-services-waiting-lists/

^(2)^ R Core Team (2024). _R: A Language and Environment for Statistical Computing_. R Foundation for Statistical Computing, Vienna, Austria. <https://www.R-project.org/>.

^(3)^ Walton N, Dray M, Smith T, Mainey C (2025). NHSRwaitinglist: Waiting List Metrics Using Queuing Theory. R package version 0.1.1, https://nhs-r-community.github.io/NHSRwaitinglist/.

^(4)^ Little JDC. A Proof for the Queuing Formula: L = λW. Operations Research. 
1961;9(3):383–7. 

^(5)^ Little JDC, Graves SC. Little’s Law. In: Chhajed, D, Lowe, TJ (eds) Building Intuition. 
Springer; 2008. (International Series in Operations Research & Management Science; 
vol. 115).

^(6)^ Understanding Waiting Lists Pressures: Kevin Fong, Yasser Mushtaq, Thomas House, Dan Gordon, Yingrae Chen, Darren Griffths, Shazaad Ahmad, Neil Walton medRxiv 2022.08.23.22279117; doi: https://doi.org/10.1101/2022.08.23.22279117

^(7)^ Norris J. Markov Chains. Cambridge University Press; 1997. (Cambridge Series in 
Statistical and Probabilistic Mathematics).

^(8)^ Paul Embrechts, Claudia Klüppelberg, and Thomas Mikosch. Modelling Extremal Events. Springer Verlag, Berlin Heidelberg, 1997. doi:10.1007/978-3-642-33483-2.